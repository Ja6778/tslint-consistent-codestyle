export {};

let foo1: number = 1;
        ~~~~~~~~ [fail]
let foo2: 1 = 1;
const foo3: number = 1;
          ~~~~~~~~ [fail]
const foo4: 1 = 1;
          ~~~ [fail]
const foo5: string[] = [];
const foo6: string[] = ["foo", "bar"];
          ~~~~~~~~~~ [fail]
const foo7 = "foo";
let foo8 = "foo";

interface Foo {
    foo: number;
}

const foo9: Foo = {foo: 1};
const foo10: Foo[] = [foo9, foo9];
           ~~~~~~~ [fail]

const fn = function(a: string, b: number) {};

declare function take<T>(cb: T): void;
declare function generic<T>(cb: (param: T, i: number) => T);
declare function genericReturn<T>(cb: () => T): T;
function genericReturn2<T>(cb: () => T) {
    return cb();
}

take<() => void>((a?: boolean) => a);
take<(a: string, b: number) => void>((a: string, b: number) => a);
                                       ~~~~~~~~ [fail]
                                                  ~~~~~~~~ [fail]
take<(a: string, b: number) => void>((a: string, b) => a);
                                       ~~~~~~~~ [fail]
take<(a: string, b: number) => void>((a, b) => a);
take<(a: "a", b: number) => void>((a: string, b: {}) => a);
generic((a: string) => a);
generic((a: string, i: number) => a);
                     ~~~~~~~~ [fail]
take<((() => void) | ((a: string) => void))>((a: string) => a); // TODO find correct signature
genericReturn((): number => {
    return 1;
});
genericReturn2((): number => {
    return 1;
});
take<(this: any, a: string) => void>((a: string) => a);
                                       ~~~~~~~~ [fail]
take<(a: string) => void>(function(this: any, a: string) => a);
                                               ~~~~~~~~ [fail]
take<(this: any, a: string) => void>(function(this: any, a: string) => a);
                                                          ~~~~~~~~ [fail]

(function(foo: "foo") {})("foo");
(function(foo: string) {})("foo");
             ~~~~~~~~ [fail]
(function(foo) {})("foo");
(function(foo?) {})("foo");
(function(param: string, ...foo: string[]) {})("foo", "bar", "baz");
               ~~~~~~~~ [fail]
(function(foo?: string) {})();
(<T>(param: T): T => {
              ~~~ [fail]
    return param;
})(1);
(function(): string { return "foo"; })();
           ~~~~~~~~ [fail]
(function cb(): string {})();
{
    const result = (function(): string { return "foo"; })();
    result = ((function(): string { return "foo"; }))();
                         ~~~~~~~~ [fail]

    const v: string | false = (function(): string | false {})
    const v: true = (function(): true { return true; })
}


const myVerboseSignature: (a: number) => number = function(a: number): number {
                        ~~~~~~~~~~~~~~~~~~~~~~~ [fail]
                                                            ~~~~~~~~ [fail]
                                                                     ~~~~~~~~ [fail]
    return a;
}

const myObj: {fn(a: string, b: number): void} = {
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [fail]
    fn(a: string, b: number) {}
        ~~~~~~~~ [fail]
                   ~~~~~~~~ [fail]
}

const myOtherObj: {fn: (a: string, b: number) => void} = {
    fn(a: string, b: number) {}
        ~~~~~~~~ [fail]
                   ~~~~~~~~ [fail]
}

const yetAnotherObject: {fn(a: string, b: number): void} = {
    fn: function(a: string, b: number) {}
                  ~~~~~~~~ [fail]
                             ~~~~~~~~ [fail]
}

const andAnotherOne: {fn: (a: string, b: number) => void} = {
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [fail]
    fn: function(a: string, b: number) {}
                  ~~~~~~~~ [fail]
                             ~~~~~~~~ [fail]
}

const evenWorkWithSignatures: {[key: string]: (a: string, b: number) => void} = {
    fn(a: string, b: number): void {},
        ~~~~~~~~ [fail]
                   ~~~~~~~~ [fail]
                            ~~~~~~ [fail]
    foo(a: string, b: number) {},
         ~~~~~~~~ [fail]
                    ~~~~~~~~ [fail]
    bar(a: string, b) {},
         ~~~~~~~~ [fail]
    baz(a): void {}
          ~~~~~~ [fail]
    [foo](a: string): void {}
}

const withLiteralType: {fn(): false} = {
                     ~~~~~~~~~~~~~~~ [fail]
    fn(): false {
        ~~~~~~~ [fail]
        return false;
    },
};

const noContext = {
    foo(a: string): void {}
}

const anyContext: any = {
    foo(a: string): void {}
}

class Clazz {
    foo(a: string): void {}
}

[fail]: type annotation is redundant
